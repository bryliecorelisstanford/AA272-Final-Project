# -*- coding: utf-8 -*-
"""KF_Final_Version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cF6g0myBXM6A2P1_VhUUfFYl3f41ecjR
"""

from google.colab import drive
from scipy.signal import butter, filtfilt
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from collections import deque
import os
import warnings

drive.mount('/content/drive', force_remount=True)
walking_straight_1 = "/content/drive/MyDrive/AA 272 - Final Project/iPhone Data/walking_straight_1.csv"
turn_1 = "/content/drive/MyDrive/AA 272 - Final Project/iPhone Data/turn_1.csv"
data1 = pd.read_csv(walking_straight_1)
spoofed_data1 = pd.read_csv(turn_1)
warnings.filterwarnings("ignore", category=RuntimeWarning)

# Time and convert to seconds
timestamps = pd.to_datetime(data1["time"])
time = (timestamps - timestamps.iloc[0]).dt.total_seconds()
timestamps_spoofed = pd.to_datetime(spoofed_data1["time"])
time_spoofed = (timestamps_spoofed - timestamps_spoofed.iloc[0]).dt.total_seconds()

# Latitude and Longitude
lat = data1["latitude"].to_numpy()
lon = data1["longitude"].to_numpy()
lat_spoofed = spoofed_data1["latitude"].to_numpy()
lon_spoofed = spoofed_data1["longitude"].to_numpy()

# Calculate the slope from last two points
x_last, y_last = lat_spoofed[-1], lon_spoofed[-1]
x_second_last, y_second_last = lat_spoofed[-2], lon_spoofed[-2]
slope = (y_last - y_second_last) / ((x_last - x_second_last))

# Extend the spoofed dataset
points_to_add = 4145 - len(time_spoofed)
x_new = np.arange(x_last + 1, x_last + 1 + points_to_add)  # New indices
y_new = y_last + slope * (x_new - x_last)  # Extrapolated values
lat_spoofed_extended = np.concatenate([lat_spoofed, x_new])
lon_spoofed_extended = np.concatenate([lon_spoofed, y_new])
lat_spoofed = lat_spoofed_extended
lon_spoofed = lon_spoofed_extended

# IMU acceleration and gyroscope data
imu_ax = data1["ax"].to_numpy()
imu_ay = data1["ay"].to_numpy()
imu_az = data1["az"].to_numpy()
gyro_gx = data1["wx"].to_numpy()
gyro_gy = data1["wy"].to_numpy()
gyro_gz = data1["wz"].to_numpy()

# Haversine formula to convert lat/lon to x/y
def haversine(lat, lon, lat_ref, lon_ref):
    R = 6371000  # Earth radius in meters
    phi_ref = np.radians(lat_ref)
    delta_phi = np.radians(lat - lat_ref)
    delta_lambda = np.radians(lon - lon_ref)
    x = R * delta_lambda * np.cos(phi_ref)  # East
    y = R * delta_phi  # North
    return x, y

# Convert GPS and spoofed GPS data to Cartesian coordinates
lat_ref, lon_ref = lat[0], lon[0]
gps_x, gps_y = haversine(lat, lon, lat_ref, lon_ref)
gps_x_spoofed, gps_y_spoofed = haversine(lat_spoofed, lon_spoofed, lat_ref, lon_ref)


# Kalman Filter Initialization
state = np.array([[gps_x[0]], [gps_y[0]], [3.31], [0]])  # Initial state: [x, y, velocity, theta/heading]
P = np.eye(4) * 0.01  # Covariance matrix
Q = np.eye(4) * 0.1  # Process noise
R_imu = np.diag([0.1, 0.1])  # IMU noise (includes gyroscope noise)
R_gnss = np.diag([5, 5])  # GNSS noise
H_gnss = np.array([[1, 0, 0, 0],
                   [0, 1, 0, 0]])  # GNSS measurement matrix
H_imu = np.array([[0, 0, 1, 0],
                  [0, 0, 0, 1]])  # IMU measurement matrix

# Kalman Filter Functions
def calculate_F(state, dt):
    _, _, v, theta = state.flatten()
    F = np.array([
        [1, 0, dt * np.cos(theta), -v * dt * np.sin(theta)],
        [0, 1, dt * np.sin(theta),  v * dt * np.cos(theta)],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ])
    return F

def predict(state, P, Q, ax, ay, gz, dt):
    F = calculate_F(state, dt)
    x, y, v, theta = state.flatten()

    # Update velocity and theta
    v_new = v + dt * np.sqrt(ax**2 + ay**2)
    theta_new = (theta + dt * gz) % (2 * np.pi)

    # Update X and Y
    x_new = x + v_new * np.cos(theta_new) * dt
    y_new = y + v_new * np.sin(theta_new) * dt

    state_pred = np.array([[x_new], [y_new], [v_new], [theta_new]])
    P_pred = F @ P @ F.T + Q
    return state_pred, P_pred


def GNSS_update(state, P, z, H, R):
    y = z - H @ state
    S = H @ P @ H.T + R
    K = P @ H.T @ np.linalg.inv(S)
    state_upd = state + K @ y
    P_upd = (np.eye(len(state)) - K @ H) @ P
    return state_upd, P_upd

def imu_update(state, P, speed, H_imu, R_imu, dt):
    theta_new = state[3, 0]  # Maintain theta
    z_imu = np.array([[speed], [theta_new]])
    y = z_imu - H_imu @ state
    S = H_imu @ P @ H_imu.T + R_imu

    # Kalman gain
    K = P @ H_imu.T @ np.linalg.inv(S)

    # Update state and covariance matrix
    state_upd = state + K @ y
    P_upd = (np.eye(len(state)) - K @ H_imu) @ P

    return state_upd, P_upd

# Reset the state based on the last norm difference below reset_threshold
def reset_state(state_history, norm_differences, state, reset_threshold=0.7, lookback_window=300):
    start_idx = max(0, len(norm_differences) - lookback_window) # Lookback window to analyze

    # Find the most recent index where norm difference is below the reset threshold
    reset_idx = None
    for i in range(len(norm_differences) - 1, start_idx, -1):
        if norm_differences[i] < reset_threshold:
            reset_idx = i
            break

    if reset_idx is not None:
        # Reset state to the position where norm difference was below the threshold
        state = state_history[reset_idx].copy()
        state[3, 0] = (state[3, 0] + np.pi) % (2 * np.pi)
    else:
        print("No stable position found for reset.")

    return state

norm_differences = []
kf_est_x, kf_est_y = [], []  # GNSS updates
kf_est_x_imu, kf_est_y_imu = [], []  # IMU-only updates
spoofing_threshold = 3  # Spoofing detection threshold
dt = np.mean(np.diff(time))
speeds = data1["speed"]
state_history = []
reset_done = False  # Flag


for t in range(len(time)):
    z_gnss = np.array([[gps_x_spoofed[t]], [gps_y_spoofed[t]]])
    state, P = predict(state, P, Q, imu_ax[t], imu_ay[t], gyro_gz[t], dt)
    norm_difference = np.linalg.norm([state[0, 0] - gps_x[t], state[1, 0] - gps_y[t]])

    norm_differences.append(norm_difference)

    # Append the current state to the history
    state_history.append(state.copy())

    # If spoofing is detected and reset hasn't been done yet, reset the state
    if norm_difference > spoofing_threshold and not reset_done:
        state = reset_state(state_history, norm_differences, state)
        reset_done = True

    # After resetting or spoofing detected, rely on IMU updates
    if reset_done or norm_difference > spoofing_threshold:
        state, P = imu_update(state, P, speeds[t], H_imu, R_imu, dt)
        kf_est_x_imu.append(state[0, 0])
        kf_est_y_imu.append(state[1, 0])
    else:
        # Normal GNSS update (before spoofing is detected)
        state, P = GNSS_update(state, P, z_gnss, H_gnss, R_gnss)

for t in range(len(time)):
    z_gnss = np.array([[gps_x_spoofed[t]], [gps_y_spoofed[t]]])
    state, P = predict(state, P, Q, imu_ax[t], imu_ay[t], gyro_gz[t], dt)

    # Normal GNSS update (before spoofing is detected)
    state, P = GNSS_update(state, P, z_gnss, H_gnss, R_gnss)
    kf_est_x.append(state[0, 0])
    kf_est_y.append(state[1, 0])


# Plot Norm Difference
plt.figure(figsize=(10, 6))
plt.plot(time, norm_differences, label="Norm Difference")
plt.axhline(y=spoofing_threshold, color='r', linestyle='--', label="Spoofing Threshold")
plt.xlabel("Time (s)")
plt.ylabel("Norm Difference")
plt.title("Norm Difference Between Kalman and Real GNSS Positions")
plt.legend()
plt.show()

# Plot Final Kalman Filter Trajectories
plt.figure(figsize=(10, 6))
plt.plot(gps_x, gps_y, label="Correct GPS Position", alpha=0.6, linewidth=3)
plt.plot(gps_x_spoofed, gps_y_spoofed, label="Spoofed GPS Position", alpha=0.6, linewidth=3, color='green')
plt.plot(kf_est_x, kf_est_y, label="Kalman Filter Position without Correction", linestyle='--', linewidth=3, color='orange')
plt.plot(kf_est_x_imu, kf_est_y_imu, label="Kalman Filter Position with Correction", linestyle='--', linewidth=3, color='red')
plt.scatter(gps_x[0], gps_y[0], color='red', label="Initial Position", zorder=5, s=100)
plt.xlabel("X Position (m)")
plt.ylabel("Y Position (m)")
plt.legend()
plt.title("Kalman Filter Fusion of GPS and IMU Data with Spoofing Detection")
plt.show()